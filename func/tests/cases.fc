int equal_slices(slice a, slice b) asm "SDEQ";

int __test_wrongmessage() {

  slice ad = my_address();

  var body = begin_cell()
    .store_uint(123, 32) ;; op
    .store_slice(my_address())
  .end_cell();
  var sbody = body.begin_parse();

  var full = begin_cell()
    .store_uint(0x6, 4)                         ;; 4 for flags 
    .store_slice(ad)                            ;; 2..267 sender_address for addr_none would be 2 bits 00 --normally will be replaced by sender address
    .store_slice(ad)                            ;; 2..267  0043800efd...73010  // destination address
    .store_coins(1000)                          ;; 4..16(?)   // VarUInteger 16 (variable size)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 ) ;; extra-currencies (1), ihr-fee (4 for empty VarUInteger 16), fwd-fee (4), cur_lt (64), now (32) init (1)
    .store_uint(1,1)              ;; Not inplace, reference for body
    .store_ref(body)
  .end_cell();
  var sfull = full.begin_parse();
  sfull~dump();


  ;; We build stack using as signature of receiver:
  ;;() recv_internal (int balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

  tuple pila = unsafe_tuple([
      1000, ;; coins
      10,  ;; msg_value
      full, ;; in_msg_full
      sbody   ;; msg_body
  ]);

  ;; We build storage with owner address as manager and no_address
  cell data = begin_cell()             ;; initial data of contract
      .store_slice(ad)               ;; counter
      .store_uint(0, 256)              ;; none_address
      .store_dict(new_dict())              
      .store_dict(new_dict())              
      .end_cell();

  int gas_usado1 = invoke_method_expect_fail(recv_internal, pila);

  return gas_usado1;
}

int __test_wrongop() {

  slice ad = my_address();

  var body = begin_cell()
    .store_uint(0, 256) ;; signature 1
    .store_uint(0, 256) ;; signature 2
    .store_uint(123, 32) ;; op
    .store_slice(my_address())
  .end_cell();
  var sbody = body.begin_parse();

  var full = begin_cell()
    .store_uint(0x6, 4)                         ;; 4 for flags 
    .store_slice(ad)                            ;; 2..267 sender_address for addr_none would be 2 bits 00 --normally will be replaced by sender address
    .store_slice(ad)                            ;; 2..267  0043800efd...73010  // destination address
    .store_coins(1000)                          ;; 4..16(?)   // VarUInteger 16 (variable size)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 ) ;; extra-currencies (1), ihr-fee (4 for empty VarUInteger 16), fwd-fee (4), cur_lt (64), now (32) init (1)
    .store_uint(1,1)              ;; Not inplace, reference for body
    .store_ref(body)
  .end_cell();
  var sfull = full.begin_parse();
  sfull~dump();


  ;; We build stack using as signature of receiver:
  ;;() recv_internal (int balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

  tuple pila = unsafe_tuple([
      1000, ;; coins
      10,  ;; msg_value
      full, ;; in_msg_full
      sbody   ;; msg_body
  ]);

  ;; We build storage with owner address as manager and no_address
  cell data = begin_cell()             ;; initial data of contract
      .store_slice(ad)               ;; address
      .store_uint(0, 256)              ;; public_key
      .store_dict(new_dict())          ;; dictionary
      .store_dict(new_dict())          ;; dictionary    
      .end_cell();

  int gas_usado1 = invoke_method_expect_fail(recv_internal, pila);

  return gas_usado1;
}
